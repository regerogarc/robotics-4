#pragma config(Sensor, S3,     Colour,         sensorEV3_Color)
#pragma config(Sensor, S4,     US,             sensorEV3_Ultrasonic)
#pragma config(Motor,  motorC,          LeftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorA,          RightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          FlipMotor,     tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SIGHT_THRESHOLD		90
#define FLIP_THRESHOLD 		5

// Global Variables --------------------------------------------------------------------------------------------------------------------------------------

int white_colour;

int drive_speed = 0;
int drive_type = 1;
int distance = 0;

// Driver functions ---------------------------------------------------------------------------------------------------------------------------

void display_motor_states(int left_speed, int right_speed)
{
	displayCenteredTextLine(4, "Left motor: %d%%", left_speed);
	displayCenteredTextLine(5, "Right motor: %d%%", right_speed);
}

//void drive(int speed)
//{
	// move both motors in the same direction
  // speed is an int between 0-100%, negative for reverse
//	setMotorSpeed(LeftMotor, speed);
//	setMotorSpeed(RightMotor, speed);

//	display_motor_states(speed, speed);
//}

void turn(int speed)
{
	// move both motors in the opposite direction to rotate the robot
  // speed is an int between 0-100%, positive for clockwise, negative for anti-clockwise
	setMotorSpeed(LeftMotor, speed);
	setMotorSpeed(RightMotor, -speed);

	display_motor_states(speed, -speed);
}

void stopRobot(void)
{
	// stop the robot's motors from moving
	setMotorSpeed(LeftMotor, 0);
	setMotorSpeed(RightMotor, 0);
}

// MUTEX LOCK ------------------------------------------------------------------------------------------------------------------------------------------------------------------

int state_lock = 0;

void aquire_state_lock() {
	displayCenteredTextLine(8, "Aquire lcok");
	while(state_lock){}
	state_lock = 1;
	displayCenteredTextLine(8, "Lock aquired");
}

void release_state_lock()
{
	displayCenteredTextLine(8, "Lock released");
	state_lock = 0;
}

// STATE MACHINE ---------------------------------------------------------------------------------------------------------------------------------------------------------------

enum States {
	SEARCHING,
	MOVING,
	EDGE_EVASION,
	ATTACK
};

int interrupt = 0;

States current_state = SEARCHING;

// State functions
void searching()
{
	displayCenteredTextLine(2, "Searching");
	//turn(100);
	while(1)
	{
		if (interrupt) return;

		distance = SensorValue[US];
		if (distance < SIGHT_THRESHOLD)
		{
			displayCenteredTextLine(4, "Target Aquired");
			stopRobot();
			aquire_state_lock();
			current_state = MOVING;
			release_state_lock();
			return;
		}
		else {
			displayCenteredTextLine(4, "Searching");
		}
	}
}

void attack()
{
	displayCenteredTextLine(2, "Attacking");
	setMotorTarget(FlipMotor, 3600, 100);

	while(1)
	{
		if (interrupt) return;

		distance = SensorValue[US];
		if (distance > FLIP_THRESHOLD)
		{
			displayCenteredTextLine(4, "Target Out of Range");

			// Reset the flipper and change back to searching state
			setMotorTarget(FlipMotor, 0, 100);
			aquire_state_lock();
			current_state = SEARCHING;
			release_state_lock();
			return;
		}
		else if (getMotorEncoder(FlipMotor) == 3600)
		{
			setMotorTarget(FlipMotor, 0, 100);
		}
		else if (getMotorEncoder(FlipMotor) == 0)
		{
			setMotorTarget(FlipMotor, 3600, -100);
		}
	}
}

void moving()
{
	displayCenteredTextLine(2, "Moving");
	drive_speed = 100;
	while(1)
	{
		if (interrupt) return;

		distance = SensorValue[US];
		if (distance > SIGHT_THRESHOLD)
		{
			displayCenteredTextLine(4, "Target Lost");
			stopRobot();
			aquire_state_lock();
			current_state = SEARCHING;
			release_state_lock();
			return;
		}
		else if (distance < FLIP_THRESHOLD)
		{
			displayCenteredTextLine(4, "Target In Range, Attacking");
			stopRobot();
			aquire_state_lock();
			current_state = ATTACK;
			release_state_lock();
			return;
		}
		else
		{
			displayCenteredBigTextLine(4, "Approaching Target");
		}
	}
}

void edge_evasion()
{
	displayCenteredTextLine(2, "Evading Edge");

	//drive(-100);
	delay(3000);
	stopRobot();

	//target_angle = getGyroDegrees();

	aquire_state_lock();
	current_state = SEARCHING;
	release_state_lock();
	return;
}


// TASKS --------------------------------------------------------------------------------------------------------------------------------------------------------
float freebird_notes[269][2] = {{739.99,48},{554.37,48},{659.26,48},{739.99,48},{739.99,48},{369.99,48},{739.99,48},{369.99,48},{659.26,48},{554.37,48},{659.26,48},{739.99,48},{659.26,48},{554.37,43},{659.26,5},{739.99,48},{440.0,48},{659.26,48},{554.37,48},{659.26,48},{739.99,48},{493.88,48},{880.0,43},{659.26,5},{739.99,48},{493.88,48},{880.0,43},{659.26,5},{739.99,48},{493.88,48},{880.0,43},{659.26,5},{739.99,48},{493.88,48},{739.99,48},{440.0,48},{659.26,48},{554.37,48},{659.26,48},{739.99,48},{739.99,48},{369.99,48},{739.99,48},{369.99,48},{659.26,48},{554.37,48},{659.26,48},{739.99,48},{659.26,48},{554.37,43},{659.26,5},{739.99,48},{440.0,48},{659.26,48},{554.37,48},{659.26,48},{739.99,48},{493.88,48},{880.0,43},{659.26,5},{739.99,48},{493.88,48},{880.0,43},{659.26,5},{739.99,48},{493.88,48},{880.0,43},{659.26,5},{739.99,48},{493.88,47},{-1,1},{880.0,23},{-1,1},{739.99,23},{-1,1},{493.88,47},{-1,1},{739.99,47},{-1,1},{554.37,36},{880.0,12},{739.99,47},{-1,1},{554.37,36},{880.0,12},{739.99,47},{-1,1},{554.37,36},{880.0,12},{739.99,47},{-1,1},{554.37,36},{880.0,12},{739.99,47},{-1,1},{554.37,36},{880.0,12},{739.99,47},{-1,1},{659.26,47},{-1,1},{659.26,47},{-1,1},{659.26,47},{-1,1},{659.26,47},{-1,1},{554.37,47},{-1,1},{554.37,47},{-1,1},{554.37,47},{-1,1},{493.88,47},{-1,1},{369.99,47},{-1,1},{493.88,47},{-1,1},{493.88,47},{-1,1},{493.88,47},{-1,1},{493.88,47},{-1,1},{493.88,47},{-1,1},{493.88,47},{-1,1},{493.88,47},{-1,1},{493.88,47},{-1,1},{493.88,47},{-1,1},{440.0,47},{-1,1},{493.88,47},{-1,1},{440.0,47},{-1,1},{369.99,47},{-1,1},{440.0,47},{-1,1},{369.99,47},{-1,1},{185.0,47},{-1,1},{185.0,47},{-1,1},{185.0,47},{-1,1},{185.0,47},{-1,1},{185.0,47},{-1,1},{369.99,24},{329.63,24},{277.18,24},{440.0,24},{369.99,48},{220.0,47},{-1,1},{220.0,47},{-1,1},{220.0,47},{-1,1},{220.0,47},{-1,1},{220.0,47},{-1,1},{369.99,24},{329.63,24},{277.18,24},{440.0,24},{369.99,48},{246.94,48},{369.99,24},{329.63,24},{277.18,24},{440.0,24},{369.99,48},{246.94,48},{369.99,24},{329.63,24},{277.18,24},{440.0,24},{369.99,48},{246.94,48},{369.99,24},{329.63,24},{277.18,24},{440.0,24},{369.99,48},{246.94,48},{277.18,48},{1108.73,48},{987.77,24},{880.0,24},{739.99,23},{-1,4},{369.99,19},{-1,2},{1108.73,48},{987.77,24},{880.0,24},{739.99,23},{-1,1},{369.99,23},{-1,1},{1108.73,48},{987.77,24},{880.0,24},{739.99,21},{-1,7},{369.99,20},{1108.73,48},{987.77,24},{880.0,24},{739.99,22},{-1,2},{369.99,22},{-1,2},{1108.73,48},{987.77,24},{880.0,24},{739.99,43},{-1,5},{739.99,24},{659.26,24},{554.37,24},{659.26,24},{739.99,48},{369.99,48},{739.99,24},{659.26,24},{554.37,24},{659.26,24},{739.99,48},{369.99,48},{739.99,24},{659.26,24},{554.37,24},{659.26,24},{739.99,48},{369.99,48},{739.99,24},{659.26,24},{554.37,24},{659.26,24},{739.99,48},{369.99,48},{739.99,24},{659.26,24},{554.37,24},{659.26,24},{739.99,24},{659.26,24},{554.37,24},{659.26,24},{739.99,24},{659.26,24},{554.37,24},{659.26,24},{739.99,24},{659.26,24},{554.37,24},{659.26,25}};
float alabama_notes[246][2] = {{587.33,96},{587.33,96},{1174.66,48},{880.0,96},{587.33,48},{523.25,96},{523.25,96},{1174.66,48},{880.0,96},{587.33,48},{392.0,96},{392.0,96},{783.99,48},{587.33,96},{493.88,48},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{1174.66,48},{880.0,96},{587.33,48},{523.25,96},{523.25,96},{1174.66,48},{880.0,96},{587.33,48},{392.0,96},{392.0,96},{783.99,48},{587.33,96},{493.88,48},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{1174.66,48},{880.0,96},{587.33,48},{523.25,96},{523.25,96},{1174.66,48},{880.0,96},{587.33,48},{392.0,96},{392.0,96},{783.99,48},{587.33,96},{493.88,48},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{1174.66,48},{880.0,96},{587.33,48},{523.25,96},{523.25,96},{1174.66,48},{880.0,96},{587.33,48},{392.0,96},{392.0,96},{783.99,48},{587.33,96},{493.88,48},{392.0,48},{587.33,48},{493.88,48},{783.99,48},{987.77,48},{783.99,48},{587.33,48},{783.99,48},{587.33,96},{587.33,96},{698.46,144},{659.26,96},{415.3,48},{659.26,96},{587.33,96},{523.25,48},{587.33,96},{587.33,48},{392.0,96},{493.88,96},{587.33,96},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{698.46,144},{659.26,96},{415.3,48},{659.26,96},{587.33,96},{523.25,48},{587.33,144},{392.0,96},{493.88,96},{587.33,96},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{698.46,144},{659.26,96},{415.3,48},{659.26,96},{587.33,96},{523.25,48},{587.33,96},{587.33,48},{392.0,96},{493.88,96},{587.33,96},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{698.46,144},{659.26,96},{415.3,48},{659.26,96},{587.33,96},{523.25,48},{587.33,144},{392.0,96},{493.88,96},{587.33,96},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{698.46,192},{659.26,192},{587.33,96},{523.25,48},{587.33,144},{587.33,96},{493.88,96},{587.33,96},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{698.46,48},{698.46,144},{659.26,192},{587.33,96},{523.25,48},{587.33,240},{493.88,96},{587.33,96},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{698.46,192},{659.26,192},{587.33,96},{523.25,48},{587.33,144},{587.33,96},{493.88,96},{587.33,96},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48},{587.33,96},{587.33,96},{698.46,48},{698.46,144},{659.26,192},{587.33,96},{523.25,48},{587.33,240},{493.88,96},{587.33,96},{392.0,48},{493.88,48},{587.33,48},{783.99,48},{587.33,48},{493.88,48},{392.0,48},{493.88,48}};

task playMusic()
{
    float timing_multiplier = 0.3;

    for (int i = 0; i < 269; i++)
    {
        if (freebird_notes[i][0] == -1)
        {
            delay(freebird_notes[i][1] * timing_multiplier);
        } else
        {
            playTone(freebird_notes[i][0], freebird_notes[i][1] * timing_multiplier);
            while(bSoundActive)
            {
                sleep(1);
            }
        }
    }

    for (int i = 0; i < 246; i++)
    {
        if (alabama_notes[i][0] == -1)
        {
            delay(alabama_notes[i][1] * timing_multiplier);
        } else
        {
            playTone(alabama_notes[i][0], alabama_notes[i][1] * timing_multiplier);
            while(bSoundActive)
            {
                sleep(1);
            }
        }
    }
}

task drive()
{
	while(1)
	{
		resetMotorEncoder(LeftMotor);
		resetMotorEncoder(RightMotor);
		delay(200);
		setMotorTarget(LeftMotor, 362, drive_speed);
		setMotorTarget(RightMotor, 360, drive_speed);
		delay(1000);
	}

}

task edge_detection()
{
	while(1)
	{
		displayCenteredTextLine(6, "Colour value: %d", SensorValue[Colour]);
		displayCenteredTextLine(7, "Colour thresh: %d", white_colour/3);

		if (SensorValue[Colour] < white_colour/3)
		{
			aquire_state_lock();
			current_state = EDGE_EVASION;
			interrupt = 1;
			release_state_lock();
		}
	}
}

task main()
{
	// Calibrate the colour sensor
	delay(500);

	int colour_average = 0;
	for (int i = 0; i < 20; i++)
	{
		colour_average += SensorValue[Colour];
		delay(25);
	}
	white_colour = colour_average/20;

	// Calibrate the flipper motor
	resetMotorEncoder(FlipMotor);

	//startTask(edge_detection);
	drive_speed = 100;
	startTask(drive);
	startTask(playMusic);
	while(1)
	{
		//setMotorSync(LeftMotor, RightMotor, 0, 100);
		//delay(8000);
		//setMotorSync(LeftMotor, RightMotor, -1, 100);
		//delay(8000);
	}

	while(0)
	{
		//state_function[current_state]();
		// run the correct function for the current state
		switch (current_state)
		{
			case SEARCHING:
				searching();
				break;
			case MOVING:
				moving();
				break;
			case EDGE_EVASION:
				edge_evasion();
				break;
			case ATTACK:
				attack();
				break;
		}

		// Reset the interrupt flag
		interrupt = 0;
	}
}
