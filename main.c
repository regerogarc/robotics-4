#pragma config(Sensor, S1,     Colour,         sensorColorNxtFULL)
#pragma config(Sensor, S2,     US,             sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     touchSensor,    sensorTouch)
#pragma config(Motor,  motorA,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SIGHT_THRESHOLD		90
#define FLIP_THRESHOLD 		5000

// Global Variables --------------------------------------------------------------------------------------------------------------------------------------

int white_colour;

int distance = 0;

// Driver functions ---------------------------------------------------------------------------------------------------------------------------

void display_motor_states(int left_speed, int right_speed)
{
	displayCenteredTextLine(4, "Left motor: %d%%", left_speed);
	displayCenteredTextLine(5, "Right motor: %d%%", right_speed);
}

void drive(int speed)
{
	// move both motors in the same direction
  // speed is an int between 0-100%, negative for reverse
	setMotorSpeed(LeftMotor, speed);
	setMotorSpeed(RightMotor, speed);

	display_motor_states(speed, speed);
}

void turn(int speed)
{
	// move both motors in the opposite direction to rotate the robot
  // speed is an int between 0-100%, positive for clockwise, negative for anti-clockwise
	setMotorSpeed(LeftMotor, speed);
	setMotorSpeed(RightMotor, -speed);

	display_motor_states(speed, -speed);
}

void stopRobot(void)
{
	// stop the robot's motors from moving
	setMotorSpeed(LeftMotor, 0);
	setMotorSpeed(RightMotor, 0);
}

// MUTEX LOCK ------------------------------------------------------------------------------------------------------------------------------------------------------------------

int state_lock = 0;

void aquire_state_lock() {
	while(state_lock){}
	state_lock = 1;
}

void release_state_lock()
{
	state_lock = 0;
}

// STATE MACHINE ---------------------------------------------------------------------------------------------------------------------------------------------------------------

enum States {
	SEARCHING,
	MOVING,
	EDGE_EVASION,
	UNFLIP
};

int interrupt = 0;

States current_state = SEARCHING;

// State functions
void searching()
{
	displayCenteredTextLine(2, "Searching");
	turn(20);
	while(1)
	{
		if (interrupt) return;

		distance = getUSDistance(US);
		if (distance < SIGHT_THRESHOLD)
		{
			displayCenteredBigTextLine(4, "Target Aquired");
			stopRobot();
			aquire_state_lock();
			current_state = MOVING;
			release_state_lock();
			return;
		}
		else {
			displayCenteredBigTextLine(4, "Searching");
		}
	}
}

void moving()
{
	displayCenteredTextLine(2, "Moving");
	drive(20);
	while(1)
	{
		if (interrupt) return;

		distance = getUSDistance(US);
		if (distance > SIGHT_THRESHOLD)
		{
			displayCenteredTextLine(4, "Target Lost");
			stopRobot();
			aquire_state_lock();
			current_state = SEARCHING;
			release_state_lock();
			return;
		}
		else
		{
			displayCenteredBigTextLine(4, "Approaching Target");
		}
	}
}

void edge_evasion()
{
	displayCenteredTextLine(2, "Evading Edge");
	int pre_turn_colour, post_turn_colour;

	while(1)
	{
		pre_turn_colour = SensorValue[Colour]; // Measure the colour that the colour sensor is detecting before turning
		if (pre_turn_colour < white_colour/1.5) { // If the colour sensor detects something 1.5x darker than the default
			// Turn in the Flag Direction
			post_turn_colour = SensorValue[Colour]; // Measure the colour after turning
		}
		if (post_turn_colour < pre_turn_colour) { // If ground is darker after turning
			// Flip the flag
			// For loop to turn a certain amount
		}
	}
}

void unflip()
{
	displayCenteredTextLine(2, "Unflip");
}

// robot c does not understand function pointers
//void(* state_function ) [4] (void) = {&searching, &moving, &edge_evasion, &unflip};

// void refine_angle()
// {
// 	int min_distance, new_distance;
// 	min_distance = getUSDistance(US);
// 	turn(0.1);
// 	while(1)
// 	{
// 		new_distance = getUSDistance(US);
// 		if (new_distance < min_distance) {
// 			break;
// 		}
// 	}
// }


// TASKS --------------------------------------------------------------------------------------------------------------------------------------------------------

task check_flip()
{
	int flip_timer;
	bool ground_detected;

	while (1)
	{
		if (current_state == MOVING || current_state == SEARCHING)
		{
			int sensor_val = getBumperValue(touchSensor);

			if (sensor_val)
			{
				ground_detected = true;
			}else
			{
				if (ground_detected)
				{
					// set the timer when the switch state is changed
					flip_timer = nPgmTime;
				}
				ground_detected = false;
			}

			int flip_elapsed = flip_timer - nPgmTime;
			if (!ground_detected && (flip_elapsed > FLIP_THRESHOLD))
			{
				aquire_state_lock();
				current_state = UNFLIP;
				interrupt = 1;
				release_state_lock();
			}
		}
	}
}

task edge_detection()
{
	while(1)
	{
		if (SensorValue[Colour] < white_colour/1.5)
		{
			aquire_state_lock();
			current_state = EDGE_EVASION;
			interrupt = 1;
			release_state_lock();
		}
	}
}

task main()
{
	// Calibrate the colour sensor
	white_colour = SensorValue[Colour];

	startTask(check_flip);
	startTask(edge_detection);

	while(1)
	{
		//state_function[current_state]();
		// run the correct function for the current state
		switch (current_state)
		{
			case SEARCHING:
				searching();
				break;
			case MOVING:
				moving();
				break;
			case EDGE_EVASION:
				edge_evasion();
				break;
			case UNFLIP:
				unflip();
				break;
		}

		// Reset the interrupt flag
		interrupt = 0;
	}
}
